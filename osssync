#!/usr/bin/env python3
"""
osssync - script-mode-only OSS push/pull helper using ossutil.

Config file: defaults to ./.sync
Each non-empty line is a command. Supports inline comments with '# ...' and quoted args.

Commands:
  log on|off                      Toggle step logging (default: on)
  stdout on|off                   Toggle printing ossutil stdout/stderr (default: on)
  profile <name>                 Set current ossutil profile for subsequent copy/rcopy
  noprofile                      Clear current profile
  copy  <src> <dst>              Copy a file (ossutil cp -u)
  rcopy <src> <dst>              Copy a folder recursively (ossutil cp -u -r)
  mode  <path> <octal>           chmod path (fail-safe; retries once with sudo -n on permission errors)
  owner <path> <owner[:group]>   chown path (fail-safe; retries once with sudo -n on permission errors)

Rules:
  - copy/rcopy must be between local and oss://... (exactly one side is oss://)
  - rcopy normalizes oss:// folder endpoints to end with '/'
  - If copying a file into a local directory destination, use a trailing '/' on <dst>
"""

from __future__ import annotations

import argparse
import grp
import os
import pwd
import shlex
import shutil
import subprocess
import sys
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple


class OssSyncError(Exception):
    pass


_OSS_URI_PREFIX = "oss://"


def format_cmd(argv: List[str]) -> str:
    return " ".join(shlex.quote(a) for a in argv)


def _use_color() -> bool:
    if os.environ.get("NO_COLOR") is not None:
        return False
    try:
        return sys.stdout.isatty()
    except Exception:
        return False


def _c(code: str, s: str) -> str:
    if not _use_color():
        return s
    return f"\033[{code}m{s}\033[0m"


def _ok(s: str) -> str:
    return _c("32", s)  # green


def _info(s: str) -> str:
    return _c("36", s)  # cyan


def _err(s: str) -> str:
    return _c("31", s)  # red


def _stdout_c(s: str) -> str:
    return _c("32", s)  # green


def _stderr_c(s: str) -> str:
    return _c("91", s)  # light red


def _ossutil_bin(*, allow_missing: bool) -> str:
    env = os.environ.get("OSSUTIL_BIN", "").strip()
    if env:
        return env
    for candidate in ("ossutil", "ossutil64"):
        found = shutil.which(candidate)
        if found:
            return found
    if allow_missing:
        return "ossutil"
    raise OssSyncError("Could not find ossutil in PATH. Install it or set OSSUTIL_BIN=/path/to/ossutil.")


def _sudo_bin() -> Optional[str]:
    return shutil.which("sudo")


def _run_sudo(cmd: List[str], *, dry_run: bool, verbose: bool) -> bool:
    sudo = _sudo_bin()
    if not sudo:
        return False
    full = [sudo, "-n", *cmd]
    if dry_run or verbose:
        print(f"  {format_cmd(full)}")
    if dry_run:
        return True
    proc = subprocess.run(full)
    return proc.returncode == 0


def _resolve_owner(owner: str) -> Tuple[int, int]:
    """
    owner can be 'user:group', 'user', ':group', and numeric ids like '1000:1000'
    """
    owner = owner.strip()
    if not owner:
        raise OssSyncError("empty owner")
    if ":" in owner:
        user_s, group_s = owner.split(":", 1)
    else:
        user_s, group_s = owner, ""

    uid = -1
    gid = -1
    if user_s:
        uid = int(user_s) if user_s.isdigit() else pwd.getpwnam(user_s).pw_uid
    if group_s:
        gid = int(group_s) if group_s.isdigit() else grp.getgrnam(group_s).gr_gid
    return uid, gid


def _shlex_split_line(line: str) -> List[str]:
    lexer = shlex.shlex(line, posix=True)
    lexer.whitespace_split = True
    lexer.commenters = "#"
    return list(lexer)


def _is_oss_uri(s: str) -> bool:
    return s.strip().startswith(_OSS_URI_PREFIX)


def _ensure_trailing_slash(s: str) -> str:
    return s if s.endswith("/") else (s + "/")


def _basename_from_uri(uri: str) -> str:
    u = uri.rstrip("/")
    return u.split("/")[-1]


@dataclass(frozen=True)
class ScriptStep:
    line_no: int
    raw: str  # original trimmed line (including any inline comment)
    display: str  # canonical command without comment, for logging
    cmd: str
    args: List[str]
    suppress_log: bool  # if true, suppress logging for this step only (supports '@cmd ...')

@dataclass(frozen=True)
class CommandSpec:
    usage: str
    min_args: int
    max_args: int


COMMAND_SPECS: Dict[str, CommandSpec] = {
    "log": CommandSpec("log <on|off>", 1, 1),
    "stdout": CommandSpec("stdout <on|off>", 1, 1),
    "profile": CommandSpec("profile <name>", 1, 1),
    "noprofile": CommandSpec("noprofile", 0, 0),
    "copy": CommandSpec("copy <src> <dst>", 2, 2),
    "rcopy": CommandSpec("rcopy <src> <dst>", 2, 2),
    "mode": CommandSpec("mode <path> <octal_mode>", 2, 2),
    "owner": CommandSpec("owner <path> <owner|owner:group|:group>", 2, 2),
}


def _validate_step_args(cmd: str, args: List[str], *, context: str) -> None:
    spec = COMMAND_SPECS.get(cmd)
    if spec is None:
        raise OssSyncError(f"{context}: unknown command {cmd!r}")
    if not (spec.min_args <= len(args) <= spec.max_args):
        raise OssSyncError(f"{context}: usage: {spec.usage}")
    if cmd in {"stdout", "log"} and args[0].lower() not in {"on", "off"}:
        raise OssSyncError(f"{context}: usage: {spec.usage}")


def parse_script_config(text: str, *, source_name: str) -> List[ScriptStep]:
    steps: List[ScriptStep] = []
    for idx, raw in enumerate(text.splitlines(), start=1):
        stripped = raw.strip()
        if not stripped or stripped.startswith("#"):
            continue
        ctx = f"{source_name}:{idx}"
        tokens = _shlex_split_line(raw)
        if not tokens:
            continue
        first = tokens[0]
        suppress_log = False
        if first.startswith("@"):
            suppress_log = True
            if len(first) == 1:
                raise OssSyncError(f"{ctx}: invalid command '@' (expected '@<command> ...')")
            first = first[1:]
        cmd = first.lower()
        args = tokens[1:]
        _validate_step_args(cmd, args, context=ctx)

        steps.append(
            ScriptStep(
                line_no=idx,
                raw=stripped,
                display=" ".join([cmd, *args]).strip(),
                cmd=cmd,
                args=args,
                suppress_log=suppress_log,
            )
        )

    if not steps:
        raise OssSyncError(f"{source_name}: no steps found")
    return steps


@dataclass
class ExecContext:
    profile: Optional[str] = None
    show_ossutil_output: bool = True  # stdout/stderr printing for ossutil
    log_steps: bool = True


def _run_ossutil(cmd: List[str], *, show_output: bool) -> subprocess.CompletedProcess:
    # Always capture so we can format output nicely (indent + color).
    # If show_output is False, we'll still print captured output on failure.
    return subprocess.run(cmd, text=True, capture_output=True)


def _normalize_newlines(text: str) -> str:
    # Normalize CRLF/CR to LF so we can format output consistently.
    return text.replace("\r\n", "\n").replace("\r", "\n")


def _write_prefixed_line(
    content: str,
    *,
    out,
    indent: str,
    colorize,
    end: str = "\n",
) -> None:
    out.write(indent + "> " + colorize(content) + end)


def _print_indented(text: str, *, is_stderr: bool, indent: str) -> None:
    """
    Print text with a prefix and preserve original newline endings.

    - Each output line is prefixed with: <indent> + "> "
    - If the input ends with a newline, we print a newline; if it doesn't, we don't add one.
    """
    if not text:
        return
    out = sys.stderr if is_stderr else sys.stdout
    colorize = _stderr_c if is_stderr else _stdout_c

    normalized = _normalize_newlines(text)
    for chunk in normalized.splitlines(keepends=True):
        ends_nl = chunk.endswith("\n")
        content = chunk[:-1] if ends_nl else chunk
        _write_prefixed_line(
            content,
            out=out,
            indent=indent,
            colorize=colorize,
            end="\n" if ends_nl else "",
        )


def _fmt_duration(seconds: float) -> str:
    if seconds < 0.001:
        return "<1ms"
    if seconds < 1:
        return f"{int(seconds * 1000)}ms"
    return f"{seconds:.2f}s"


def run_copy(
    ossutil: str,
    *,
    src: str,
    dst: str,
    recursive: bool,
    profile: Optional[str],
    dry_run: bool,
    verbose: bool,
    show_ossutil_output: bool,
    output_indent_prefix: str,
    log_command: bool,
) -> None:
    src_is_oss = _is_oss_uri(src)
    dst_is_oss = _is_oss_uri(dst)
    if src_is_oss == dst_is_oss:
        raise OssSyncError("copy/rcopy requires exactly one side to be oss://...")

    if recursive:
        if src_is_oss:
            src = _ensure_trailing_slash(src)
        if dst_is_oss:
            dst = _ensure_trailing_slash(dst)
    else:
        src_base = Path(src).name if not src_is_oss else _basename_from_uri(src)
        if dst_is_oss and dst.endswith("/"):
            dst = dst + src_base
        if (not dst_is_oss) and (dst.endswith("/") or dst.endswith(os.sep)):
            dst = str(Path(dst) / src_base)

    cmd: List[str] = [ossutil, "cp", "-u"]
    if recursive:
        cmd.append("-r")
    cmd.extend([src, dst])
    if profile:
        cmd.extend(["--profile", profile])

    # Dynamic indentation: width of "<digits>. " (based on the file line number)
    indent = " " * len(output_indent_prefix)

    if verbose or log_command:
        _write_prefixed_line(format_cmd(cmd), out=sys.stdout, indent=indent, colorize=_info)

    if dry_run:
        return

    if not src_is_oss:
        p = Path(src)
        if not p.is_absolute():
            p = (Path.cwd() / p).resolve()
        if not p.exists():
            raise OssSyncError(f"Local source does not exist: {p}")
        if recursive and not p.is_dir():
            raise OssSyncError(f"rcopy expects a directory local source: {p}")
        if (not recursive) and not p.is_file():
            raise OssSyncError(f"copy expects a file local source: {p}")
    else:
        dp = Path(dst)
        if not dp.is_absolute():
            dp = (Path.cwd() / dp).resolve()
        if recursive:
            dp.mkdir(parents=True, exist_ok=True)
        else:
            dp.parent.mkdir(parents=True, exist_ok=True)

    proc = _run_ossutil(cmd, show_output=show_ossutil_output)
    # Print ossutil output if stdout is enabled, or if the command failed.
    if show_ossutil_output or proc.returncode != 0:
        _print_indented(proc.stdout or "", is_stderr=False, indent=indent)
        _print_indented(proc.stderr or "", is_stderr=True, indent=indent)
    if proc.returncode != 0:
        raise OssSyncError(f"ossutil failed (exit {proc.returncode})")


def run_mode(
    *,
    path: str,
    mode_s: str,
    dry_run: bool,
    verbose: bool,
    output_indent_prefix: str,
    log_command: bool,
) -> None:
    target = Path(path)
    if not target.is_absolute():
        target = (Path.cwd() / target).resolve()

    indent = " " * len(output_indent_prefix)
    if verbose or log_command:
        _write_prefixed_line(f"chmod {mode_s} {target}", out=sys.stdout, indent=indent, colorize=_info)

    if dry_run:
        return

    if not target.exists():
        print(f"[WARN] mode: path does not exist, skipping: {target}", file=sys.stderr)
        return

    try:
        mode_int = int(mode_s, 8)
        os.chmod(target, mode_int, follow_symlinks=False)
    except PermissionError:
        cmd = ["chmod", mode_s, "--", str(target)]
        if log_command or verbose:
            _write_prefixed_line(format_cmd(["sudo", "-n", *cmd]), out=sys.stdout, indent=indent, colorize=_info)
        ok = _run_sudo(cmd, dry_run=dry_run, verbose=verbose)
        if not ok:
            print(f"[WARN] mode: failed to chmod {mode_s} {target} (and sudo retry failed)", file=sys.stderr)
    except ValueError:
        print(f"[WARN] mode: invalid mode {mode_s!r} (expected octal like '0700')", file=sys.stderr)
    except OSError as e:
        print(f"[WARN] mode: failed to chmod {mode_s} {target}: {e}", file=sys.stderr)


def run_owner(
    *,
    path: str,
    owner: str,
    dry_run: bool,
    verbose: bool,
    output_indent_prefix: str,
    log_command: bool,
) -> None:
    target = Path(path)
    if not target.is_absolute():
        target = (Path.cwd() / target).resolve()

    indent = " " * len(output_indent_prefix)
    if verbose or log_command:
        _write_prefixed_line(f"chown {owner} {target}", out=sys.stdout, indent=indent, colorize=_info)

    if dry_run:
        return

    if not target.exists():
        print(f"[WARN] owner: path does not exist, skipping: {target}", file=sys.stderr)
        return

    try:
        uid, gid = _resolve_owner(owner)
        os.chown(target, uid, gid, follow_symlinks=False)
    except PermissionError:
        cmd = ["chown", owner, "--", str(target)]
        if log_command or verbose:
            _write_prefixed_line(format_cmd(["sudo", "-n", *cmd]), out=sys.stdout, indent=indent, colorize=_info)
        ok = _run_sudo(cmd, dry_run=dry_run, verbose=verbose)
        if not ok:
            print(f"[WARN] owner: failed to chown {owner} {target} (and sudo retry failed)", file=sys.stderr)
    except KeyError as e:
        print(f"[WARN] owner: unknown user/group in owner {owner!r}: {e}", file=sys.stderr)
    except OSError as e:
        print(f"[WARN] owner: failed to chown {owner} {target}: {e}", file=sys.stderr)


def execute_step(
    *,
    ctx: ExecContext,
    ossutil: str,
    step: ScriptStep,
    dry_run: bool,
    verbose: bool,
) -> None:
    """
    Executes a single step.
    """
    match step.cmd:
        case "log":
            ctx.log_steps = step.args[0].lower() == "on"
            return

        case "stdout":
            ctx.show_ossutil_output = step.args[0].lower() == "on"
            return

        case "profile":
            ctx.profile = step.args[0]
            return

        case "noprofile":
            ctx.profile = None
            return

        case "copy":
            src, dst = step.args
            run_copy(
                ossutil,
                src=src,
                dst=dst,
                recursive=False,
                profile=ctx.profile,
                dry_run=dry_run,
                verbose=verbose,
                show_ossutil_output=ctx.show_ossutil_output and (not step.suppress_log),
                output_indent_prefix=f"{step.line_no}. ",
                log_command=ctx.log_steps and (not step.suppress_log),
            )
            return

        case "rcopy":
            src, dst = step.args
            run_copy(
                ossutil,
                src=src,
                dst=dst,
                recursive=True,
                profile=ctx.profile,
                dry_run=dry_run,
                verbose=verbose,
                show_ossutil_output=ctx.show_ossutil_output and (not step.suppress_log),
                output_indent_prefix=f"{step.line_no}. ",
                log_command=ctx.log_steps and (not step.suppress_log),
            )
            return

        case "mode":
            path, mode_s = step.args
            run_mode(
                path=path,
                mode_s=mode_s,
                dry_run=dry_run,
                verbose=verbose,
                output_indent_prefix=f"{step.line_no}. ",
                log_command=ctx.log_steps and (not step.suppress_log),
            )
            return

        case "owner":
            path, owner_s = step.args
            run_owner(
                path=path,
                owner=owner_s,
                dry_run=dry_run,
                verbose=verbose,
                output_indent_prefix=f"{step.line_no}. ",
                log_command=ctx.log_steps and (not step.suppress_log),
            )
            return

        case _:
            # Should be unreachable due to parse-time validation, but keep it fail-safe.
            raise OssSyncError(f"Unhandled command: {step.cmd}")


def run_steps(ossutil: str, *, steps: List[ScriptStep], dry_run: bool, verbose: bool) -> None:
    ctx = ExecContext()
    for step in steps:
        prefix = f"{step.line_no}. "
        subprefix = " " * len(prefix)
        log_before = ctx.log_steps
        should_log = (not step.suppress_log) and (log_before or step.cmd == "log")

        if should_log:
            print(_info(f"{prefix}Executing {step.display}..."))
        try:
            t0 = time.monotonic()
            execute_step(ctx=ctx, ossutil=ossutil, step=step, dry_run=dry_run, verbose=verbose)
            dt = _fmt_duration(time.monotonic() - t0)
            # Print done after execution. Use the original logging decision so "log off" still prints.
            if should_log:
                print(_ok(f"{subprefix}...done ({dt})"))
        except Exception as e:
            # Print a single failure line then re-raise (main will exit non-zero).
            print(_err(f"{prefix}FAIL: {e}"), file=sys.stderr)
            raise


def main(argv: List[str]) -> int:
    parser = argparse.ArgumentParser(
        prog="osssync",
        description="Run a .sync script to copy via ossutil and apply chmod/chown (script mode).",
    )
    parser.add_argument("-c", "--config", default=".sync", help="Path to script config (default: ./.sync)")
    parser.add_argument("--list", action="store_true", help="List steps and exit")
    parser.add_argument(
        "--only",
        action="append",
        default=[],
        help="Only run steps whose full line matches exactly (can be provided multiple times)",
    )
    parser.add_argument("--dry-run", action="store_true", help="Print commands without executing")
    parser.add_argument("-v", "--verbose", action="store_true", help="Print commands")
    args = parser.parse_args(argv)

    config_path = Path(args.config)
    try:
        text = config_path.read_text(encoding="utf-8")
    except FileNotFoundError as e:
        raise OssSyncError(f"Config file not found: {config_path}") from e

    steps = parse_script_config(text, source_name=str(config_path))

    if args.list:
        for s in steps:
            print(f"STEP: {s.raw}")
        return 0

    only_set = set(args.only or [])
    if only_set:
        steps = [s for s in steps if s.raw in only_set]
        if not steps:
            raise OssSyncError(f"--only names not found in config: {sorted(only_set)!r}")

    ossutil = _ossutil_bin(allow_missing=bool(args.dry_run))
    run_steps(ossutil, steps=steps, dry_run=args.dry_run, verbose=args.verbose)
    return 0


if __name__ == "__main__":
    try:
        raise SystemExit(main(sys.argv[1:]))
    except OssSyncError as e:
        print(f"Error: {e}", file=sys.stderr)
        raise SystemExit(2)




